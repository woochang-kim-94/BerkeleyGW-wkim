!=============================================================================
!
! Utilities:
!
! (1) wfnmix_QSGW        Originally By DVF       Last Modified 7/14/2010 (DVF)
!
!     This code takes in a set of wavefunctions, and outputs
!     a new set of wavefunctions that are linear combinations
!     of the input wavefunctions. The coefficients of these linear combinations
!     are read from eigenval_vec.log file generated by Sigma/offdiag_QSGW.f90
!
!     The k-points in WFN and eigenval_vec.log must be in the same order,
!     no sanity check is performed. The spin-polarized version is not tested yet.
!
!==============================================================================

#include "f_defs.h"

program wfnmix_QSGW

  use blas_m
  use global_m
  use misc_m
  use wfn_rho_vxc_io_m
  implicit none

  type(crystal) :: crys
  type(symmetry) :: syms
  type(kpoints) :: kp
  type(gspace) :: gvec

  character*80  :: infile, outfile
  character*256 :: s_sig
  integer :: nbands,bandno,bmin,bmax,ierr,ispin,ik,ibmin,ibmax,nargs,ib,jb
  
  real(DP) :: QSGW_ave,eldaev,slope,intercept
  real(DP) :: ecor,ex,sx,ch,sig,vxc,eqp0,eqp1,QSGW_sum
  real(DP) :: tempreal, tempimag

  complex(DPC) :: ovlp
  
  SCALAR, allocatable :: wfn(:,:,:), wfn_new(:,:,:)
  SCALAR, allocatable :: eigvec(:,:,:,:)
  real(DP), allocatable :: elda(:,:,:)

  character*3 :: sheader
  integer :: iflavor
  
  write(6,*) MYFLAVOR // ' version is used to convert file'

!---------------------------------
! Get file names from command-line arguments

  nargs = command_argument_count()
  
  if (nargs .ne. 2) then
    call die('Usage: wfnmix_QSGW wfn_name_old wfn_name_new')
  endif
  
  call get_command_argument(1,infile)
  call get_command_argument(2,outfile)

!This extracts the slope and intercept needed for higher diagonal fit
!See p.13 of van Schilfgaarde paper listed at top of offdiag_QSGW.f90 in
!Sigma directory for details

  call open_file(unit=20,file="wfnmix_QSGW.inp",form="formatted",status='old')
  read(20,131) slope
  read(20,131) intercept
  call close_file(20)

131 format(f12.6)

! Open units

  call open_file(unit=7,file=TRUNC(infile),form='unformatted',status='old')
  call open_file(unit=8,file=TRUNC(outfile),form='unformatted',status='replace')
  write(6,*) 'Converting file ',TRUNC(infile),' into Van Schilfgaarde wavefunction file'

! Read/write data

  sheader = 'WFN'
  iflavor = 0
  call read_binary_header_type(7, sheader, iflavor, kp, gvec, syms, crys, warn = .false.)

  if(kp%nspin*kp%nspinor.eq.2) then
    call die('wfnmix_QSGW does not support spinor wavefunctions and LSDA case is untested')
  endif

  call write_binary_header_type(8, sheader, iflavor, kp, gvec, syms, crys)


!DVF: The following block does the following tasks
!sequentially:
!1. Reads in eigenvalues from eigenval_vec.log
!2. Employs higher energy diagonal approximation
!3. Band averaging of states degenerate at lda level
!4. Converts the energies from the eigenval_vec.log 
!file, which is in eV, to Rydbergs
!5. Reads in eigenvectors from eigenval_vec.log

  call open_file(unit=10,file="eigenval_vec.log",form="formatted",status='old')
  read(10,*) bmin,bmax
  nbands=bmax-bmin+1
  
  SAFE_ALLOCATE(eigvec,(kp%mnband,kp%mnband,kp%nspin,kp%nrk))
  eigvec=ZERO
  do ib=1,kp%mnband
    eigvec(ib,ib,:,:)=ONE
  enddo
  
  do ik=1,kp%nrk
    do ispin=1,kp%nspin
      read(10,*)
      read(10,*)
      do ib=bmax+1,kp%mnband
        elda(ib,ik,ispin)=kp%el(ib,ik,ispin)
      enddo
      do ib=bmin,bmax
        read(10,*) bandno,kp%el(ib,ik,ispin)    
      enddo
      do ib=bmax+1,kp%mnband
        kp%el(ib,ik,ispin)=slope*kp%el(ib,ik,ispin)+intercept/RYD  
      enddo
      
      QSGW_sum=0.0d0
      do ib=1,kp%mnband
        ibmin=ib
        ibmax=ib
        do jb=ib+1,kp%mnband
          if (abs(kp%el(ib,ik,ispin)-kp%el(jb,ik,ispin)) < TOL_Degeneracy) then
            ibmax=ib
            exit
          endif
          ibmax=jb
        enddo
        do jb = ibmin,ibmax
          QSGW_sum = QSGW_sum+kp%el(jb,ik,ispin)
        enddo
        QSGW_ave = QSGW_sum/(ibmax-ibmin+1.0d0)
        QSGW_sum = 0.0d0
        do jb = ibmin,ibmax
          kp%el(jb,ik,ispin)=QSGW_ave
        enddo
      enddo
      
      do ib=bmin,bmax
        kp%el(ib,ik,ispin)=kp%el(ib,ik,ispin)/RYD    
      enddo
      read(10,*)
      do ib=bmin,bmax
        do jb=bmin,bmax
          read(10,*) tempreal, tempimag
          eigvec(jb,ib,ispin,ik) = CMPLX(tempreal,tempimag)
        enddo
        read(10,*)
      enddo
      write(8) (kp%el(ib,ik,ispin),ib=1,kp%mnband)
    enddo ! ispin
  enddo ! ik
  SAFE_DEALLOCATE(kp%el)
  SAFE_DEALLOCATE(elda)
  call close_file(10)
  
  SAFE_ALLOCATE(gvec%components, (3, gvec%ng))

  call read_binary_gvectors(7, gvec%ng, gvec%ng, gvec%components)
  call write_binary_gvectors(8, gvec%ng, gvec%ng, gvec%components)
  
! Output info

  write(6,*) ' crystal volume: ',crys%celvol
  write(6,*) ' number of spins: ',kp%nspin
  write(6,*) ' number of bands in file: ',kp%mnband
  
  SAFE_ALLOCATE(wfn, (kp%mnband, kp%ngkmax, kp%nspin))
  SAFE_ALLOCATE(wfn_new, (bmax, kp%ngkmax, kp%nspin))

  do ik = 1, kp%nrk
    call read_binary_gvectors(7, kp%ngk(ik), kp%ngk(ik), gvec%components)
    call write_binary_gvectors(8, kp%ngk(ik), kp%ngk(ik), gvec%components)
    
    do ib = 1, kp%mnband
      call read_binary_data(7, kp%ngk(ik), kp%ngkmax, kp%nspin, wfn(ib,:,:))
      do ispin = 1, kp%nspin
        call checknorm('old wfn',ib,ik,kp%ngk(ik),ispin,kp%nspinor,wfn(ib,:,:))
      enddo
    enddo

    do ispin=1,kp%nspin
      call X(gemm)('N','N',bmax,kp%ngkmax,bmax,ONE,eigvec(:,:,ispin,ik),bmax,&
        wfn(:,:,ispin),bmax,ZERO,wfn_new(:,:,ispin),bmax)
      do ib=1,bmax
        call checknorm('new wfn',ib,ik,kp%ngk(ik),ispin,kp%nspinor,wfn_new(ib,:,:))
      enddo
    enddo
    
    do ispin=1,kp%nspin
      do ib=1,bmax
        do jb=1,ib-1
          ovlp=blas_dot(kp%ngk(ik),wfn_new(ib,:,ispin),1,(wfn_new(jb,:,ispin)),1)
          if (abs(ovlp).gt.TOL_Small) then
            write(6,998) ik,ispin,ib,jb,ovlp
998         format(1x,"dot_prod error: ik =",i4,1x,"is =",i2,1x,"ib =",i4,1x,"jb =",i4,1x,"prod =",2f12.6)
          endif
        enddo
      enddo
    enddo

    do ib = 1, bmax
      call write_binary_data(8, kp%ngk(ik), kp%ngkmax, kp%nspin, wfn_new(ib,:,:))
    enddo

    ! higher diagonal approximation
    do ib = bmax + 1, kp%mnband
      call write_binary_data(8, kp%ngk(ik), kp%ngkmax, kp%nspin, wfn(ib,:,:))
    enddo
    
  enddo
  
  call close_file(7)
  call close_file(8)

  SAFE_DEALLOCATE_P(gvec%components)
  call dealloc_header_type(sheader, crys, kp)
  
  write(6,*) 'Done '
  
end program wfnmix_QSGW
